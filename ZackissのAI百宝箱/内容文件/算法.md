# ç®—æ³•

### ç®—æ³•æ—¶é—´

æˆ‘ä»¬ä½¿ç”¨ $T(n)$ å‡½æ•°è¡¡é‡ç®—æ³•è¿è¡Œæ—¶é—´å’Œç®—æ³•çš„æ¶ˆè€—ï¼Œå…¶ä¸­ $n$ æ˜¯æŒ‡è¾“å…¥çš„å¤§å°ã€‚

- ä½¿ç”¨æ¸è¿›è¡¨ç¤ºï¼ˆAsymptotic Notationï¼‰å¿½ç•¥æ­¤å‡½æ•°ä¸­çš„å¸¸é‡ä¸æ¬¡è¦å¢é•¿é¡¹ï¼š
    - ä¸Šç•Œè¡¨ç¤ºï¼ˆUpper Boundï¼‰
        
        ```math
        T(n)=O(f(n))
        ```
        
        å¦‚æœå­˜åœ¨å¸¸æ•° $c>0$ï¼Œæˆ‘ä»¬æœ‰ $n_0$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰çš„ $n\geq n_0$ï¼Œéƒ½æœ‰ $T(n)\leq c\cdot f(n)$ã€‚
        
    - ä¸‹ç•Œè¡¨ç¤ºï¼ˆLower Boundï¼‰
        
        $$
        T(n)=\Omega(f(n))
        $$
        
        å¦‚æœå­˜åœ¨å¸¸æ•° $c>0$ï¼Œæˆ‘ä»¬æœ‰ $n_0$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰çš„ $n\geq n_0$ï¼Œéƒ½æœ‰ $T(n)\geq c\cdot f(n)$ã€‚
        
    - ä¸¥æ ¼ä¸Šä¸‹ç•Œï¼ˆTight Boundï¼‰
        
        $$
        T(n)=\Theta(f(n))
        $$
        
        $T(n)$ åŒæ—¶ç¬¦åˆå…¶ä¸Šä¸¤ç§å½¢å¼ï¼Œåˆ™ä¸ºä¸¥æ ¼ä¸Šä¸‹ç•Œçš„è¡¨ç¤ºã€‚
        
- å¸¸è§ç®—æ³•æ—¶é—´
    
    $$
    9^{900}<\log_{10}n<n^{0.1}<n\cdot \log n<n^2<2^n
    $$
    
    - ä¸€äº›ä¾‹å­
        - $9^{900}=\Theta(1)=O(\log\log n)$
        - $\log(\log n)=O(\log n)$
        - $n\log n=O(\frac{n^2}{\log n})$
        - $n^{0.1}+\log_{10}n=\Theta(n^{0.1})$
        - $n^{100}=O(2^n)$

### æ’åº

- é€‰æ‹©æ’åº
    - ç®—æ³•æµç¨‹
        
        åœ¨ç¬¬ $i$ æ¬¡æŸ¥æ‰¾ä¸­ï¼Œæ‰¾åˆ° $A[i\cdots n]$ ä¸­æœ€å°çš„é¡¹ï¼Œå°†å®ƒä¸ $A[i]$ äº’æ¢ã€‚
        
    - ä»£ç å®ç°
        
        ```python
        def selection_sort(A):
        	for i in range(len(A)):
        		for j in range(i, len(A)):
        			if A[i] > A[j]:
        				A[i], A[j] = A[j], A[i]
        	return A
        ```
        
- æ’å…¥æ’åº
    - ç®—æ³•æµç¨‹
        
        æ•°ç»„ä¸ºæ’åºä¸æ··ä¹±ä¸¤éƒ¨åˆ†ç»„æˆï¼Œåˆ©ç”¨é¡¹ $i$ ç”±å³å‘å·¦é€ä¸ªäº’æ¢ï¼Œç›´è‡³è¯¥é¡¹åº”å¤„çš„ä½ç½®ã€‚
        
    - ä»£ç å®ç°
        
        ```python
        def insertion_sort(A):
        	for i in range(1, len(A)-1):
        		j = i - 1
        		while j >= 1 and A[j] > A[j+1]:
        			A[j], A[j+1] = A[j+1], A[j]
        			j -= 1
        ```
        
- å½’å¹¶æ’åº
    - ç®—æ³•æµç¨‹
        
        å…ˆå°†æ•°ç»„ä¸æ–­åœ°åˆ†ä¸ºå°ä»½ï¼Œåˆ©ç”¨èåˆçš„è¿‡ç¨‹æŒ‰é¡ºåºæ’å›ä¸Šçº§æ•°ç»„ï¼Œæ’åºå®Œæˆã€‚
        
    - ä»£ç å®ç°
        
        ```python
        def merge_sort(A, p, r):
        	if p == r:
        		return
        	q = (p + r)//2
        	merge_sort(p, q)
        	merge_sort(q+1, r)
        	merge(A, p, q, r)
        	return A
        
        def merge(A, p, q, r):
        	M = A[p:q].append(float("inf"))
        	N = A[q:r].append(float("inf"))
        	m, n = 0
        	while p <= r:
        		if M[m] < N[n]:
        			A[p] = M[m]
        			m += 1
        		elif M[m] > N[n]:
        			A[p] = N[n]
        			n += 1
        		p += 1
        ```
        

### æŸ¥æ‰¾

- äºŒåˆ†æŸ¥æ‰¾
    - ç®—æ³•æµç¨‹
        
        é€šè¿‡æ¯”è¾ƒå¾…æ‰¾æ•°å­—ä¸ä¸­ä½æ•°çš„å¤§å°å…³ç³»ï¼Œå†³å®šäºŒåˆ†æŸ¥æ‰¾çš„æ–¹å‘
        
    - ä»£ç å®ç°
        
        ```python
        def binary_search(A, p, r ,x):
        	if p > r:
        			return None
        	q = (p + r)//2
        	if x == A[q]:
        		return q
        	elif x < A[q]:
        		binary_search(A, p, q-1, x)
        	else:
        		binary_search(A, q, r, x)
        ```
        
    

### é€†åºæ•°

<aside>
ğŸ’¡ é€†åºæ•°æ˜¯æ•°ç»„ä¸­é€†åºçš„æ•°å­—å¯¹çš„æ•°é‡ï¼Œæ­ç¤ºäº†ä¸€ä¸ªæ•°ç»„æ’åºçš„éš¾æ˜“ç¨‹åº¦

</aside>
